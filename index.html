<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dot Sphere</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background: linear-gradient(135deg, #333 0%, #1a1a1a 50%, #000 100%); /* Shades of grey and black */
            cursor: default; /* Default cursor */
        }
        canvas {
            display: block; /* Remove extra space below inline canvas */
        }
    </style>
</head>
<body>
    <canvas id="sphereCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script>
        // --- Essential Setup ---
        const canvas = document.getElementById('sphereCanvas');
        if (!canvas) {
            console.error("Canvas element not found!");
            // You might want to stop script execution here if canvas is critical
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Transparent renderer background

        // --- Sphere Configuration ---
        const sphereRadius = 2.5;
        const dotCount = 700;
        const dotSize = 0.04;
        const purpleColor = 0x8A2BE2; // Purple

        // --- Particle System ---
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = [];         // Flat array [x1,y1,z1, x2,y2,z2, ...]
        const originalPositions = []; // Array of THREE.Vector3
        const particleData = [];      // Stores { isDisplaced: bool, activeAnimation: animeInstance | null }

        // Fibonacci lattice for even sphere distribution
        const samples = dotCount;
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        for (let i = 0; i < samples; i++) {
            const y = 1 - (i / (samples - 1)) * 2;  // y goes from 1 to -1
            const radiusAtY = Math.sqrt(1 - y * y); // radius at this y
            const theta = goldenAngle * i;

            const x = Math.cos(theta) * radiusAtY * sphereRadius;
            const z = Math.sin(theta) * radiusAtY * sphereRadius;
            const finalY = y * sphereRadius;

            positions.push(x, finalY, z);
            originalPositions.push(new THREE.Vector3(x, finalY, z));
            particleData.push({ isDisplaced: false, activeAnimation: null });
        }

        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: purpleColor,
            size: dotSize,
            sizeAttenuation: true
        });
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        camera.position.z = 5.5;

        // --- Mouse Interaction ---
        const mouse = new THREE.Vector2(-100, -100); // Initialize off-screen
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.15; // Sensitivity for hitting points

        let lastIntersectedIndices = new Set();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        document.addEventListener('mousemove', onMouseMove, false);

        // --- Animation Logic (Anime.js) ---
        const repulsionStrength = 0.8;
        const animationDurationBase = 350;

        function animateDotToTarget(index, targetPosition, easing, duration) {
            if (particleData[index].activeAnimation) {
                particleData[index].activeAnimation.pause(); // Stop existing animation
            }

            const posArray = particlesGeometry.attributes.position.array;
            // Create a temporary object for Anime.js to tween, then update buffer in 'update'
            let currentAnimatedValues = {
                x: posArray[index * 3],
                y: posArray[index * 3 + 1],
                z: posArray[index * 3 + 2]
            };

            particleData[index].activeAnimation = anime({
                targets: currentAnimatedValues,
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                duration: duration,
                easing: easing,
                update: function() {
                    posArray[index * 3]     = currentAnimatedValues.x;
                    posArray[index * 3 + 1] = currentAnimatedValues.y;
                    posArray[index * 3 + 2] = currentAnimatedValues.z;
                    particlesGeometry.attributes.position.needsUpdate = true;
                },
                complete: function() {
                    particleData[index].activeAnimation = null;
                    // Note: isDisplaced is managed by the calling functions (repelDot/returnDot)
                }
            });
        }

        function repelDot(index) {
            // Avoid re-repelling if already moving away due to mouse, unless animation finished
            if (particleData[index].isDisplaced && particleData[index].activeAnimation) return;
            particleData[index].isDisplaced = true;

            const currentPos = new THREE.Vector3().fromBufferAttribute(particlesGeometry.attributes.position, index);
            
            // Simple repulsion: away from a point near the mouse on the sphere's apparent surface
            const mouseDirection = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera).sub(camera.position).normalize();
            const intersectionPoint = new THREE.Ray(camera.position, mouseDirection).intersectSphere(new THREE.Sphere(new THREE.Vector3(), sphereRadius), new THREE.Vector3());
            
            let repelFromPoint = currentPos; // Default if no clear intersection
            if (intersectionPoint) {
                repelFromPoint = intersectionPoint;
            } else { // Fallback if mouse is far, repel radially from center
                repelFromPoint = new THREE.Vector3(0,0,0);
            }

            const directionToRepel = currentPos.clone().sub(repelFromPoint).normalize();
            const targetPos = currentPos.clone().add(directionToRepel.multiplyScalar(repulsionStrength));

            animateDotToTarget(index, targetPos, 'easeOutQuad', animationDurationBase);
        }

        function returnDot(index) {
            if (!particleData[index].isDisplaced) return; // Already home or not marked as displaced
            
            // Only start return if no active animation or if the active animation is not already returning to origin
             const originalPos = originalPositions[index];
            if (particleData[index].activeAnimation) {
                const currentTarget = particleData[index].activeAnimation.animations[0].tweens[0].endValues;
                if (currentTarget.x === originalPos.x && currentTarget.y === originalPos.y && currentTarget.z === originalPos.z) {
                    return; // Already returning to origin
                }
            }

            particleData[index].isDisplaced = false; // Mark as returning/returned
            animateDotToTarget(index, originalPos, 'easeOutElastic(1, .7)', animationDurationBase + 200);
        }

        // --- Render Loop ---
        function renderLoop() {
            requestAnimationFrame(renderLoop);

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particleSystem);
            const currentIntersectedIndices = new Set();

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                for (const intersect of intersects) {
                    if (intersect.index !== undefined) {
                        currentIntersectedIndices.add(intersect.index);
                        if (!lastIntersectedIndices.has(intersect.index)) {
                            repelDot(intersect.index);
                        }
                    }
                }
            } else {
                document.body.style.cursor = 'default';
            }

            lastIntersectedIndices.forEach(index => {
                if (!currentIntersectedIndices.has(index)) {
                    returnDot(index);
                }
            });
            lastIntersectedIndices = new Set(currentIntersectedIndices); // Create a new Set

            particleSystem.rotation.y += 0.0002; // Slower rotation
            particleSystem.rotation.x += 0.0001;

            renderer.render(scene, camera);
        }

        // --- Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        // --- Start ---
        console.log("Interactive sphere initialized. Check console for Three.js/Anime.js messages if issues.");
        renderLoop();

    </script>
</body>
</html>
