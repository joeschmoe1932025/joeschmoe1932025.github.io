<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dot Sphere & Blog UI</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            /* The gradient is now on the container that HOLDS the canvas,
               or you can keep it on the body if the canvas stacks correctly above it.
               Let's try keeping it on body first and adjusting canvas container z-index. */
            background: linear-gradient(135deg, #111 0%, #333 50%, #000 100%);
            color: #eee;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        #sphere-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* MODIFICATION: Removed z-index: -1 or set to 0 */
            /* z-index: -1; */ /* This was likely the issue */
             z-index: 0; /* Or simply remove the z-index line */
            pointer-events: none; /* Allows clicking through to content below it */
        }

        #sphereCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .content-wrapper {
            position: relative; /* Establishes a stacking context */
            z-index: 1;       /* Ensures this is above the sphere-container */
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            flex-grow: 1;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            border-bottom: 1px solid #444;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 0.2em;
            color: #e0e0e0;
        }

        header p {
            font-size: 1.1em;
            color: #aaa;
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 20px 0;
            margin-bottom: 30px;
        }

        .modern-btn {
            background-color: #500080;
            color: white;
            border: none;
            padding: 12px 25px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            font-weight: 500;
            border-radius: 25px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .modern-btn:hover {
            background-color: #6a00aa;
            transform: translateY(-2px);
        }

        .modern-btn:active {
            background-color: #400066;
            transform: translateY(0px);
        }

        main {
            background: rgba(30, 30, 30, 0.85); /* Slightly more opaque for readability */
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        article {
            margin-bottom: 30px;
        }

        article h2 {
            color: #c0c0c0;
            border-bottom: 2px solid #500080;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        article p {
            line-height: 1.7;
            color: #bbb;
        }

        footer {
            text-align: center;
            padding: 30px 20px;
            border-top: 1px solid #444;
            margin-top: 40px;
            color: #888;
        }
    </style>
</head>
<body>
    <!-- Sphere container will be here, fixed positioned -->
    <div id="sphere-container">
        <canvas id="sphereCanvas"></canvas>
    </div>

    <!-- Content wrapper will sit on top due to z-index -->
    <div class="content-wrapper">
        <header>
            <h1>My Modern Blog</h1>
            <p>Exploring interactive design and web technologies</p>
        </header>

        <nav>
            <button class="modern-btn">Home</button>
            <button class="modern-btn" id="aboutBtn">About</button>
            <button class="modern-btn">Articles</button>
            <button class="modern-btn" id="contactBtnMojs">Contact (Mo.js)</button>
        </nav>

        <main>
            <article>
                <h2>Welcome to the Future of UI</h2>
                <p>This page demonstrates an interactive background sphere created with Three.js, Anime.js, and Velocity.js. The dots in the sphere react to your cursor, moving away and then returning to their original positions. The UI elements, like the buttons, are styled for a modern look, with one button featuring an animation from Mo.js.</p>
            </article>
            <article>
                <h2>Technology Stack</h2>
                <p>We're using a blend of powerful JavaScript libraries:</p>
                <ul>
                    <li><strong>Three.js:</strong> For the 3D rendering of the dot sphere.</li>
                    <li><strong>Anime.js:</strong> For smooth animations of the dots.</li>
                    <li><strong>Velocity.js:</strong> Also contributing to dot animations.</li>
                    <li><strong>Mo.js:</strong> To add delightful micro-interactions to UI elements.</li>
                </ul>
            </article>
        </main>

        <footer>
            <p>Â© 2023 Interactive Web Demo. All rights reserved.</p>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.2/velocity.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mojs/core@1.4.0/build/mo.umd.min.js"></script>

    <script>
        // --- Three.js Sphere Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('sphereCanvas'),
            alpha: true // Make canvas background transparent
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Ensure renderer clear color is transparent

        const sphereRadius = 2.5;
        const dotCount = 500; // Reduced for potentially better performance on some machines
        const dotSize = 0.05; // Adjust if dots are too small/large
        const purpleColor = 0x8A2BE2;

        const particlesGeometry = new THREE.BufferGeometry();
        const positions = [];
        const originalPositions = [];
        const particleData = [];

        for (let i = 0; i < dotCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / dotCount);
            const theta = Math.sqrt(dotCount * Math.PI) * phi;
            const x = sphereRadius * Math.cos(theta) * Math.sin(phi);
            const y = sphereRadius * Math.sin(theta) * Math.sin(phi);
            const z = sphereRadius * Math.cos(phi);
            positions.push(x, y, z);
            originalPositions.push(new THREE.Vector3(x, y, z));
            particleData.push({ isDisplaced: false, velocityAnimation: null, animeAnimation: null });
        }
        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: purpleColor,
            size: dotSize,
            sizeAttenuation: true
        });
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        camera.position.z = 5;

        // --- Mouse Interaction ---
        const mouse = new THREE.Vector2(-100, -100); // Initialize off-screen
        const raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 0.15; // Increased threshold for easier interaction

        let lastIntersectedIndices = new Set();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            // No need to check pointer-events here, handled by CSS on sphere-container
        }
        // Listen on document because sphere-container might have pointer-events: none
        document.addEventListener('mousemove', onMouseMove, false);


        // --- Animation Logic ---
        const repulsionStrength = 0.7; // How far dots move
        const repulsionDuration = 250; // ms for Velocity
        const returnSpeed = 700;    // ms for Anime.js

        function repelDot(index) {
            if (particleData[index].isDisplaced) return;
            particleData[index].isDisplaced = true;

            if (particleData[index].animeAnimation) particleData[index].animeAnimation.pause();
            if (particleData[index].velocityAnimation) Velocity(particleData[index].velocityAnimation.elements, "stop");


            const currentPos = new THREE.Vector3(
                particlesGeometry.attributes.position.getX(index),
                particlesGeometry.attributes.position.getY(index),
                particlesGeometry.attributes.position.getZ(index)
            );
            const originalPos = originalPositions[index];

            // Repel radially outward from the sphere's perceived center (or dot's original position)
            // For simplicity, let's assume repulsion pushes it slightly further from its original spot
            // in the direction from the sphere center to the mouse projection on the XY plane of the dot.
            // A simpler radial push:
            const direction = currentPos.clone().normalize(); // From origin to current dot pos
            
            // A slightly more nuanced repulsion: vector from original point to mouse, scaled
            // This requires projecting mouse onto the sphere or a near plane, which is more complex.
            // Let's stick to a simpler radial push from its own original position, pushed further by 'mouse influence'
            const pushDirection = currentPos.clone().sub(new THREE.Vector3(mouse.x*sphereRadius, mouse.y*sphereRadius, currentPos.z )).normalize(); // very rough
             if (pushDirection.lengthSq() === 0) pushDirection.set(Math.random()-0.5, Math.random()-0.5, 0).normalize();


            const targetPos = currentPos.clone().add(pushDirection.multiplyScalar(repulsionStrength));
            
            const posArray = particlesGeometry.attributes.position.array;
            const startValues = { x: posArray[index * 3], y: posArray[index * 3 + 1], z: posArray[index * 3 + 2] };

            // Velocity.js requires an element or a collection of elements.
            // We can't directly animate array indices. So, we animate a temporary object.
            let animatedProxy = { ...startValues };

            particleData[index].velocityAnimation = Velocity(
                animatedProxy, // The object whose properties will be animated
                { x: targetPos.x, y: targetPos.y, z: targetPos.z },
                {
                    duration: repulsionDuration,
                    easing: "easeOutQuad",
                    progress: function(elements, complete, remaining, start, tweenValue) {
                        // 'elements' here will be the animatedProxy object
                        posArray[index * 3] = animatedProxy.x;
                        posArray[index * 3 + 1] = animatedProxy.y;
                        posArray[index * 3 + 2] = animatedProxy.z;
                        particlesGeometry.attributes.position.needsUpdate = true;
                    },
                    complete: function() {
                        particleData[index].velocityAnimation = null;
                    }
                }
            );
            // Store the proxy on the animation data if you need to stop it by "elements"
            // However, Velocity also returns the animation call ID which can be used.
            // For simplicity, we're just stopping all animations on that dot.
        }

        function returnDot(index) {
            if (!particleData[index].isDisplaced || particleData[index].animeAnimation) return; // Already home or returning

            if (particleData[index].velocityAnimation) Velocity(particleData[index].velocityAnimation.elements, "stop");

            const originalPos = originalPositions[index];
            const posArray = particlesGeometry.attributes.position.array;

            let currentAnimatedPos = {
                x: posArray[index * 3],
                y: posArray[index * 3 + 1],
                z: posArray[index * 3 + 2]
            };
            
            particleData[index].animeAnimation = anime({
                targets: currentAnimatedPos,
                x: originalPos.x,
                y: originalPos.y,
                z: originalPos.z,
                duration: returnSpeed,
                easing: 'easeOutElastic(1, .7)',
                update: function() {
                    posArray[index * 3] = currentAnimatedPos.x;
                    posArray[index * 3 + 1] = currentAnimatedPos.y;
                    posArray[index * 3 + 2] = currentAnimatedPos.z;
                    particlesGeometry.attributes.position.needsUpdate = true;
                },
                complete: function() {
                    particleData[index].isDisplaced = false;
                    particleData[index].animeAnimation = null;
                }
            });
        }

        // --- Mo.js Button Animation ---
        const mojsButton = document.getElementById('contactBtnMojs');
        if (mojsButton) {
            const burst = new mojs.Burst({
                parent: mojsButton,
                radius: { 0: 70 },
                count: 10,
                angle: { 0: 120 },
                children: {
                    shape: 'circle',
                    fill: '#8A2BE2',
                    radius: {10: 0},
                    stroke: '#500080',
                    strokeWidth: 1,
                    duration: 700,
                    easing: 'cubic.out'
                }
            });
            mojsButton.addEventListener('click', function (e) {
                burst.replay();
            });
        }

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particleSystem);
            const currentIntersectedIndices = new Set();

            if (intersects.length > 0) {
                // document.body.style.cursor = 'pointer'; // Can be distracting globally
                for (const intersect of intersects) {
                    if (intersect.index !== undefined) {
                        currentIntersectedIndices.add(intersect.index);
                        if (!lastIntersectedIndices.has(intersect.index)) {
                            repelDot(intersect.index);
                        }
                    }
                }
            } else {
                // document.body.style.cursor = 'default';
            }

            lastIntersectedIndices.forEach(index => {
                if (!currentIntersectedIndices.has(index)) {
                    returnDot(index);
                }
            });
            
            lastIntersectedIndices = new Set(currentIntersectedIndices); // Update for next frame

            particleSystem.rotation.y += 0.0005;
            particleSystem.rotation.x += 0.0003;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
