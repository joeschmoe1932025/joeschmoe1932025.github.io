<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dot Sphere</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
            color: #fff;
            font-family: sans-serif;
            overflow: hidden; /* Hide scrollbars */
        }

        #sphere-container {
            width: 500px; /* Adjust as needed */
            height: 500px; /* Adjust as needed */
            position: relative;
            /* This is crucial for 3D transforms of children */
            transform-style: preserve-3d;
            perspective: 1000px; /* How "deep" the 3D effect is */
        }

        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #00ffcc; /* A nice bright color */
            border-radius: 50%;
            box-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc;
            /* Dots will be positioned by JS */
            left: 50%; /* Center origin for transforms */
            top: 50%;  /* Center origin for transforms */
            margin-left: -4px; /* Half of width */
            margin-top: -4px;  /* Half of height */
            opacity: 0; /* Start invisible for initial animation */
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="sphere-container">
        <!-- Dots will be generated here by JavaScript -->
    </div>
    <div id="instructions">Move your mouse to rotate the sphere.</div>

    <script>
        const sphereContainer = document.getElementById('sphere-container');
        const numDots = 200; // Number of dots
        const sphereRadius = 200; // Radius of the sphere in pixels
        const dotElements = [];

        // Mouse position tracking with smoothing
        let mouseX = 0, mouseY = 0;
        let targetMouseX = 0, targetMouseY = 0;
        const easingFactor = 0.08; // Adjust for more/less smoothing

        // --- 1. Create Dots ---
        function createDots() {
            for (let i = 0; i < numDots; i++) {
                const dot = document.createElement('div');
                dot.classList.add('dot');
                sphereContainer.appendChild(dot);

                // Fibonacci sphere algorithm for even distribution
                const phi = Math.acos(-1 + (2 * i) / numDots);
                const theta = Math.sqrt(numDots * Math.PI) * phi;

                // Store initial spherical coordinates and a unique radius variation
                dot.dataset.phi = phi;
                dot.dataset.theta = theta;
                // Add a little randomness to radius for depth variation
                dot.dataset.radiusOffset = (Math.random() - 0.5) * (sphereRadius * 0.1);

                dotElements.push(dot);
            }
        }

        // --- 2. Update Dot Positions (called every frame) ---
        function updateDotPositions() {
            // Smoothly update current mouse position towards target
            mouseX += (targetMouseX - mouseX) * easingFactor;
            mouseY += (targetMouseY - mouseY) * easingFactor;

            // Calculate rotation angles based on mouse position
            // Map mouseX from -windowWidth/2 to +windowWidth/2 to -PI to +PI (for Y-axis rotation)
            // Map mouseY from -windowHeight/2 to +windowHeight/2 to -PI/2 to +PI/2 (for X-axis rotation)
            const rotationY = (mouseX / window.innerWidth) * Math.PI * 2;
            const rotationX = (mouseY / window.innerHeight) * Math.PI;

            dotElements.forEach(dot => {
                const phi = parseFloat(dot.dataset.phi);
                const theta = parseFloat(dot.dataset.theta);
                const radiusOffset = parseFloat(dot.dataset.radiusOffset);
                const currentRadius = sphereRadius + radiusOffset;

                // Spherical to Cartesian (initial position)
                let x = currentRadius * Math.sin(phi) * Math.cos(theta);
                let y = currentRadius * Math.sin(phi) * Math.sin(theta);
                let z = currentRadius * Math.cos(phi);

                // Apply Y-axis rotation (based on mouseX)
                let tempX = x;
                x = tempX * Math.cos(rotationY) - z * Math.sin(rotationY);
                z = tempX * Math.sin(rotationY) + z * Math.cos(rotationY);

                // Apply X-axis rotation (based on mouseY)
                let tempY = y;
                y = tempY * Math.cos(rotationX) - z * Math.sin(rotationX);
                z = tempY * Math.sin(rotationX) + z * Math.cos(rotationX);

                // Perspective scaling: dots further away (larger Z) are smaller and dimmer
                // Adjust perspectiveStrength to control how much Z affects scale and opacity
                const perspectiveStrength = 800; // Lower values = more pronounced perspective
                const scale = perspectiveStrength / (perspectiveStrength + z);

                dot.style.transform = `translate3d(${x}px, ${y}px, ${z}px) scale(${Math.max(0, scale)})`;
                dot.style.opacity = Math.max(0.1, scale * 0.9); // Ensure minimum opacity
                dot.style.zIndex = Math.floor(scale * 1000); // Basic z-ordering
            });
        }

        // --- 3. Mouse Move Listener ---
        window.addEventListener('mousemove', (event) => {
            // Convert mouse position to be relative to center of screen
            targetMouseX = event.clientX - window.innerWidth / 2;
            targetMouseY = event.clientY - window.innerHeight / 2;
        });

        // --- 4. Initial Animation & Main Loop ---
        function init() {
            createDots();

            // Initial animation for dots appearing
            anime({
                targets: '.dot',
                opacity: [0, 1], // Animate from opacity 0 to their calculated opacity
                scale: [0, 1],   // Animate from scale 0
                translateZ: [-100, 0], // Come from a bit further back
                delay: anime.stagger(10), // Stagger appearance
                duration: 1500,
                easing: 'easeOutExpo',
                complete: () => {
                    // Start the continuous update loop after intro animation
                    anime({
                        targets: {}, // Dummy target, we only use the update callback
                        update: updateDotPositions,
                        duration: Infinity, // Run forever
                        easing: 'linear'    // Not really used, but good practice
                    });
                }
            });
        }

        // --- 5. Handle Window Resize ---
        // (Optional, but good practice if container size is relative)
        window.addEventListener('resize', () => {
            // Recalculate mouse center if needed, or adjust sphereRadius based on window size
            // For this demo, it's less critical as mouse positions are normalized.
        });

        // Start everything
        init();
    </script>
</body>
</html>
